"""Script containing the base scenario kernel class."""

import logging
import random
import numpy as np
import json
import os
from flow.utils.rllib import FlowParamsEncoder
from flow.core.kernel.scenario.base import KernelScenario

# length of vehicles in the network, in meters
VEHICLE_LENGTH = 5


class AimsunKernelScenario(KernelScenario):
    """Base scenario kernel.

    This kernel subclass is responsible for generating any simulation-specific
    components needed to simulate a traffic network. This may include network
    creating configuration files that support the generating of certain traffic
    networks in a simulator (e.g. sumo), or may be as simple as passing network
    features from the scenario class (see flow/scenarios/base_scenario.py) and
    transferring them to the simulator kernel later on.

    In addition to generating files for network initialization, the scenario
    kernel performs two auxiliary tasks:

    * State acquisition: The scenario kernel contains several methods that can
      be used to acquire state information on the properties of the network
      that is being simulated, e.g. the number of lanes on an edge, the length
      of an edge, the available routes from a starting position, etc... If, for
      example, you would like to determine the maximum speed a vehicle can
      travel within the network, this can be done by calling the following
      command:

        >>> from flow.envs.base_env import Env
        >>> env = Env(...)
        >>> max_speed = env.k.scenario.max_speed()

      All relevant methods may be found within the Flow documentation.

    * Methods for generating initial vehicle positions: Initial vehicle
      positions are generated by the abstract scenario kernel, and may be
      overridden by the network generated from a flow.scenarios.Scenario object
      if the spacing in ``initial_config`` is set to random. Default initial
      positions include uniform starting positions (where all vehicles are
      equally spacing) or random starting positions (limited by some min_gap).
      For more details on how to augment the starting position of vehicles,
      see:  # TODO: create tutorial
    """

    def __init__(self, master_kernel):
        """Instantiate the base scenario kernel.

        Parameters
        ----------
        master_kernel : flow.core.kernel.Kernel
            the higher level kernel (used to call methods from other
            sub-kernels)
        """
        KernelScenario.__init__(self, master_kernel)

        self.master_kernel = master_kernel
        self.kernel_api = None
        self.network = None

        self.edges = None
        self.nodes = None
        self.types = None
        self.connections = None
        self.routes = None
        self.net_params = None

    def generate_network(self, scenario):
        self.edges = scenario.edges
        self.routes = scenario.routes
        self.nodes = scenario.nodes
        self.types = scenario.types
        self.connections = scenario.connections
        self.net_params = scenario.net_params

        output = {
            "edges": self.edges,
            "nodes": self.nodes,
            "types": self.types,
            "net_params": self.net_params
        }
        cur_dir = os.path.dirname(__file__)
        # TODO: add current time
        with open(os.path.join(cur_dir, 'data.json'), 'w') as outfile:
            json.dump(output, outfile,
                      cls=FlowParamsEncoder, sort_keys=True, indent=4)

        return self.edges, self.connections

    def pass_api(self, kernel_api):
        """Acquire the kernel api that was generated by the simulation kernel.

        Parameters
        ----------
        kernel_api : any
            an API that may be used to interact with the simulator
        """
        self.kernel_api = kernel_api

    def update(self, reset):
        """Update the scenario with current state information.

        Since scenarios are generally static, this will most likely not include
        any actions being performed. This is primarily here for consistency
        with other sub-kernels.

        Parameters
        ----------
        reset : bool
            specifies whether the simulator was reset in the last simulation
            step
        """
        pass

    def close(self):
        """Close the scenario."""
        # delete the json file that was used to read the scenario data
        cur_dir = os.path.dirname(__file__)
        os.remove(os.path.join(cur_dir, 'data.json'))

    ###########################################################################
    #                        State acquisition methods                        #
    ###########################################################################

    def edge_length(self, edge_id):
        """Return the length of a given edge/junction.

        Return -1001 if edge not found.
        """
        # Aimsun script
        # section_inf = AKIInfNetGetSectionANGInf(int(edge_id))
        # edge_length = section_inf.length
        try:
            return self._edges[edge_id]["length"]
        except KeyError:
            print('Error in edge length with key', edge_id)
            return -1001

    def length(self):
        """Return the total length of all junctions and edges."""
        # Aimsun script
        # Length of all edges
        # num_sections = AKIInfNetNbSectionsANG()
        # length_all_edges = 0
        # for i in range(num_sections):
        #     edge_id = AKIInfNetGetSectionANGId(i)
        #     edge_length = self.edge_length(edge_id)
        #     length_all_edges += edge_length
        #
        # # length of all junctions
        # num_junctions = AKIInfNetNbJunctions()
        # length_all_junctions = 0
        # for i in range(num_junctions):
        #     junction_id = AKIInfNetGetJunctionId(i)
        #     junction_length = 0 #TODO check this, no function for junc length
        #     length_all_junctions += junction_length
        return sum(self.edge_length(edge_id)
                   for edge_id in self.get_edge_list())

    def speed_limit(self, edge_id):
        """Return the speed limit of a given edge/junction.

        Return -1001 if edge not found.
        """
        # Aimsun script
        # section_inf = AKIInfNetGetSectionANGInf(int(edge_id))
        # speed_limit = section_inf.speedLimit
        try:
            return self._edges[edge_id]["speed"]
        except KeyError:
            print('Error in speed limit with key', edge_id)
            return -1001

    def max_speed(self):
        """Return the maximum achievable speed on any edge in the network."""
        # Aimsun script
        # num_sections = AKIInfNetNbSectionsANG()
        # maximum_speed = 0
        # for i in range(num_sections):
        #     edge_id = AKIInfNetGetSectionANGId(i)
        #     edge_speed_limit = self.speed_limit(edge_id)
        #     if edge_speed_limit > maximum_speed:
        #         maximum_speed = edge_speed_limit
        return max(
            self.speed_limit(edge) for edge in self.get_edge_list())

    def num_lanes(self, edge_id):
        """Return the number of lanes of a given edge/junction.

        Return -1001 if edge not found.
        """
        # Aimsun script
        # section_inf = AKIInfNetGetSectionANGInf(int(edge_id))
        # num_central_lanes = section_inf.nbCentralLanes
        # num_side_lanes = section_inf.nbSideLanes
        # num_lanes = num_central_lanes + num_side_lanes
        try:
            return self._edges[edge_id]["lanes"]
        except KeyError:
            print('Error in num lanes with key', edge_id)
            return -1001

    def get_edge_list(self):
        """Return the names of all edges in the network."""
        # Aimsun script
        # edge_list = []
        # num_sections = AKIInfNetNbSectionsANG()
        # for i in range(num_sections):
        #     edge_id = AKIInfNetGetSectionANGId(i)
        #     section_name = ANGConnGetObjectNameA(edge_id)
        #     edge_list.append(section_name)
        return [
            edge_id for edge_id in self._edges.keys() if edge_id[0] != ":"
        ]

    def get_junction_list(self):
        """Return the names of all junctions in the network."""
        # Aimsun script
        # junction_list = []
        # num_junctions = AKIInfNetNbJunctions()
        # for i in range(num_junctions):
        #     junction_id = AKIInfNetGetJunctionId(i)
        #     junction_name = ANGConnGetObjectNameA(junction_id)
        #     junction_list.append(junction_name)
        return list(
            set(self._edges.keys()) - set(self._edge_list))

    def get_edge(self, x):  # TODO: maybe remove
        """Compute an edge and relative position from an absolute position.

        Parameters
        ----------
        x : float
            absolute position in network

        Returns
        -------
        edge position : tup
            1st element: edge name (such as bottom, right, etc.)
            2nd element: relative position on edge
        """
        for (edge, start_pos) in reversed(self.network.total_edgestarts):
            if x >= start_pos:
                return edge, x - start_pos

    def get_x(self, edge, position):  # TODO: maybe remove
        """Return the absolute position on the track.

        Parameters
        ----------
        edge : str
            name of the edge
        position : float
            relative position on the edge

        Returns
        -------
        absolute_position : float
            position with respect to some global reference
        """
        # if there was a collision which caused the vehicle to disappear,
        # return an x value of -1001
        if len(edge) == 0:
            return -1001

        if edge[0] == ":":
            try:
                return self.network.internal_edgestarts_dict[edge] + position
            except KeyError:
                # in case several internal links are being generalized for
                # by a single element (for backwards compatibility)
                edge_name = edge.rsplit("_", 1)[0]
                return self.network.total_edgestarts_dict.get(edge_name, -1001)
        else:
            return self.network.total_edgestarts_dict[edge] + position

    def next_edge(self, edge, lane):
        """Return the next edge/lane pair from the given edge/lane.

        These edges may also be internal links (junctions). Returns an empty
        list if there are no edge/lane pairs in front.
        """
        # next_pairs = []
        # sec_inf = self.kernel_api.AKIInfNetGetSectionANGInf(int(edge))
        # num_connections = sec_inf.nbTurnings
        # if num_connections == 0:
        #     return next_pairs
        #
        # for elem in range(num_connections):
        #     next_edge = \
        #         self.kernel_api.AKIInfNetGetIdSectionANGDestinationofTurning(
        #             int(edge), elem + 1)
        #     next_lane = \
        #         self.kernel_api.AKIInfNetGetDestinationFromLaneofTurning(
        #             int(edge), elem + 1)
        #     next_pairs.append([next_edge, next_lane])
        try:
            return self._connections["next"][edge][lane]
        except KeyError:
            return []

    def prev_edge(self, edge, lane):
        """Return the edge/lane pair right before this edge/lane.

        These edges may also be internal links (junctions). Returns an empty
        list if there are no edge/lane pairs behind.
        """
        try:
            return self._connections["prev"][edge][lane]
        except KeyError:
            return []

    ###########################################################################
    #            Methods for generating initial vehicle positions.            #
    ###########################################################################

    def generate_starting_positions(self,
                                    initial_config,
                                    num_vehicles=None,
                                    **kwargs):
        """Generate starting positions for vehicles in the network.

        Calls all other starting position generating classes.

        Parameters
        ----------
        initial_config : flow.core.params.InitialConfig
            see flow/core/params.py
        num_vehicles : int, optional
            number of vehicles to be placed on the network. If no value is
            specified, the value is collected from the vehicles class
        kwargs : dict
            additional arguments that may be updated beyond initial
            configurations, such as modifying the starting position

        Returns
        -------
        startpositions : list of tuple (float, float)
            list of start positions [(edge0, pos0), (edge1, pos1), ...]
        startlanes : list of int
            list of start lanes
        startvel : list of float
            list of start speeds
        """
        num_vehicles = num_vehicles or self.network.vehicles.num_vehicles

        if initial_config.spacing == "uniform":
            startpositions, startlanes, startvel = self.gen_even_start_pos(
                initial_config, num_vehicles, **kwargs)
        elif initial_config.spacing == "random":
            startpositions, startlanes, startvel = self.gen_random_start_pos(
                initial_config, num_vehicles, **kwargs)
        elif initial_config.spacing == "custom":
            startpositions, startlanes, startvel = self.gen_custom_start_pos(
                initial_config, num_vehicles, **kwargs)
        else:
            raise ValueError('"spacing" argument in initial_config does not '
                             'contain a valid option')

        return startpositions, startlanes, startvel

    def gen_even_start_pos(self, initial_config, num_vehicles, **kwargs):
        """Generate uniformly spaced starting positions.

        If the perturbation term in initial_config is set to some positive
        value, then the start positions are perturbed from a uniformly spaced
        distribution by a gaussian whose std is equal to this perturbation
        term.

        Parameters
        ----------
        initial_config : InitialConfig type
            see flow/core/params.py
        num_vehicles : int
            number of vehicles to be placed on the network
        kwargs : dict
            extra components, usually defined during reset to overwrite initial
            config parameters

        Returns
        -------
        startpositions : list of tuple (float, float)
            list of start positions [(edge0, pos0), (edge1, pos1), ...]
        startlanes : list of int
            list of start lanes
        startvel : list of float
            list of start speeds
        """
        (x0, min_gap, bunching, lanes_distr, available_length,
         available_edges, initial_config) = \
            self._get_start_pos_util(initial_config, num_vehicles, **kwargs)

        increment = available_length / num_vehicles

        # if not all lanes are equal, then we must ensure that vehicles are in
        # two edges at the same time
        flag = False
        lanes = [self.num_lanes(edge) for edge in self.get_edge_list()]
        if any(lanes[0] != lanes[i] for i in range(1, len(lanes))):
            flag = True

        x = x0
        car_count = 0
        startpositions, startlanes = [], []

        # generate uniform starting positions
        while car_count < num_vehicles:
            # collect the position and lane number of each new vehicle
            pos = self.get_edge(x)

            # ensures that vehicles are not placed in an internal junction
            while pos[0] in dict(self.network.internal_edgestarts).keys():
                # find the location of the internal edge in total_edgestarts,
                # which has the edges ordered by position
                edges = [tup[0] for tup in self.network.total_edgestarts]
                indx_edge = next(
                    i for i, edge in enumerate(edges) if edge == pos[0])

                # take the next edge in the list, and place the car at the
                # beginning of this edge
                if indx_edge == len(edges) - 1:
                    next_edge_pos = self.network.total_edgestarts[0]
                else:
                    next_edge_pos = self.network.total_edgestarts[
                        indx_edge + 1]

                x = next_edge_pos[1]
                pos = (next_edge_pos[0], 0)

            # ensures that you are in an acceptable edge
            while pos[0] not in available_edges:
                x = (x + self.edge_length(pos[0])) % self.length()
                pos = self.get_edge(x)

            # ensure that in variable lane settings vehicles always start a
            # vehicle's length away from the start of the edge. This, however,
            # prevents the spacing to be completely uniform.
            if flag and pos[1] < VEHICLE_LENGTH:
                pos0, pos1 = pos
                pos = (pos0, VEHICLE_LENGTH)
                x += VEHICLE_LENGTH
                increment -= (VEHICLE_LENGTH * self.num_lanes(pos0)) / \
                             (num_vehicles - car_count)

            # place vehicles side-by-side in all available lanes on this edge
            for lane in range(min([self.num_lanes(pos[0]), lanes_distr])):
                car_count += 1
                startpositions.append(pos)
                startlanes.append(lane)

                if car_count == num_vehicles:
                    break

            x = (x + increment + VEHICLE_LENGTH + min_gap) % self.length()

        # add a perturbation to each vehicle, while not letting the vehicle
        # leave its current edge
        if initial_config.perturbation > 0:
            for i in range(num_vehicles):
                perturb = np.random.normal(0, initial_config.perturbation)
                edge, pos = startpositions[i]
                pos = max(0, min(self.edge_length(edge), pos + perturb))
                startpositions[i] = (edge, pos)

        # all vehicles start with an initial speed of 0 m/s
        startvel = [0 for _ in range(len(startlanes))]

        return startpositions, startlanes, startvel

    def gen_random_start_pos(self, initial_config, num_vehicles, **kwargs):
        """Generate random starting positions.

        Parameters
        ----------
        initial_config : InitialConfig type
            see flow/core/params.py
        num_vehicles : int
            number of vehicles to be placed on the network
        kwargs : dict
            extra components, usually defined during reset to overwrite initial
            config parameters

        Returns
        -------
        startpositions : list of tuple (float, float)
            list of start positions [(edge0, pos0), (edge1, pos1), ...]
        startlanes : list of int
            list of start lanes
        startvel : list of float
            list of start speeds
        """
        (x0, min_gap, bunching, lanes_distr, available_length,
         available_edges, initial_config) = self._get_start_pos_util(
            initial_config, num_vehicles, **kwargs)

        # extra space a vehicle needs to cover from the start of an edge to be
        # fully in the edge and not risk having a gap with a vehicle behind it
        # that is smaller than min_gap
        efs = min_gap + VEHICLE_LENGTH  # extra front space

        for edge in available_edges:
            available_length -= efs * min([self.num_lanes(edge), lanes_distr])

        # choose random positions for each vehicle
        init_absolute_pos = \
            [random.random() * available_length
             for _ in range(num_vehicles)]

        # sort the positions of vehicles, for simplicity in using
        init_absolute_pos.sort()

        # these positions do not include the length of the vehicle, which need
        # to be added
        for i in range(num_vehicles):
            init_absolute_pos[i] += (VEHICLE_LENGTH + min_gap) * i

        decrement = 0
        edge_indx = 0
        startpositions = []
        startlanes = []
        for i in range(num_vehicles):
            edge_i = available_edges[edge_indx]
            pos_i = (init_absolute_pos[i] - decrement) % (
                    self.edge_length(edge_i) - efs)
            lane_i = int(((init_absolute_pos[i] - decrement) - pos_i) /
                         (self.edge_length(edge_i) - efs))

            pos_i += efs

            while lane_i > min([self.num_lanes(edge_i), lanes_distr]) - 1:
                decrement += min([self.num_lanes(edge_i), lanes_distr]) \
                             * (self.edge_length(edge_i) - efs)
                edge_indx += 1

                edge_i = available_edges[edge_indx]
                pos_i = (init_absolute_pos[i] - decrement) % (
                        self.edge_length(edge_i) - efs)

                lane_i = int(((init_absolute_pos[i] - decrement) - pos_i) /
                             (self.edge_length(edge_i) - efs))

                pos_i += efs

            startpositions.append((edge_i, pos_i))
            startlanes.append(lane_i)

        # all vehicles start with an initial speed of 0 m/s
        startvel = [0 for _ in range(len(startlanes))]

        return startpositions, startlanes, startvel

    def gen_custom_start_pos(self, initial_config, num_vehicles, **kwargs):
        """Generate a user defined set of starting positions.

        Parameters
        ----------
        initial_config : InitialConfig type
            see flow/core/params.py
        num_vehicles : int
            number of vehicles to be placed on the network
        kwargs : dict
            extra components, usually defined during reset to overwrite initial
            config parameters

        Returns
        -------
        startpositions : list of tuple (float, float)
            list of start positions [(edge0, pos0), (edge1, pos1), ...]
        startlanes : list of int
            list of start lanes
        startvel : list of float
            list of start speeds
        """
        raise NotImplementedError

    def _get_start_pos_util(self, initial_config, num_vehicles, **kwargs):
        """Prepare initial_config data for starting position methods.

        Performs some pre-processing to the initial_config and **kwargs terms,
        and returns the necessary values for all starting position generating
        functions.

        Parameters
        ----------
        initial_config : InitialConfig type
            see flow/core/params.py
        num_vehicles : int
            number of vehicles to be placed on the network
        kwargs : dict
            extra components, usually defined during reset to overwrite initial
            config parameters

        Returns
        -------
        x0 : float
            starting position of the first vehicle, in meters
        min_gap : float
            minimum gap between vehicles
        bunching : float
            the amount of space freed up in the network (per lane)
        lanes_distribution : int
            number of lanes the vehicles are supposed to be distributed over
        available_length : float
            total available free space for vehicle to be placed, over all lanes
            within the distributable lanes, in meters
        initial_config : InitialConfig type
            modified version of the initial_config parameter

        Raises
        ------
        ValueError
            If there is not enough space to place all vehicles in the allocated
            space in the network with the specified minimum gap.
        """
        x0 = initial_config.x0
        # changes to x0 in kwargs suggests a switch in between rollouts, and so
        # overwrites anything in initial_config
        if "x0" in kwargs:
            x0 = kwargs["x0"]

        bunching = initial_config.bunching
        # check if requested bunching value is not valid (negative)
        if bunching < 0:
            logging.warning('"bunching" cannot be negative; setting to 0')
            bunching = 0
        # changes to bunching in kwargs suggests a switch in between rollouts,
        #  and so overwrites anything in initial_config
        if "bunching" in kwargs:
            bunching = kwargs["bunching"]

        # compute the lanes distribution (adjust of edge cases)
        if initial_config.edges_distribution == "all":
            max_lane = max(
                [self.num_lanes(edge_id) for edge_id in self.get_edge_list()])
        else:
            max_lane = max([
                self.num_lanes(edge_id)
                for edge_id in initial_config.edges_distribution
            ])

        if initial_config.lanes_distribution > max_lane:
            lanes_distribution = max_lane
        elif initial_config.lanes_distribution < 1:
            logging.warning('"lanes_distribution" is too small; setting to 1')
            lanes_distribution = 1
        else:
            lanes_distribution = initial_config.lanes_distribution

        if initial_config.edges_distribution == "all":
            distribution_length = \
                sum([self.edge_length(edge_id) *
                     min([self.num_lanes(edge_id), lanes_distribution])
                     for edge_id in self.get_edge_list()])
        else:
            distribution_length = \
                sum([self.edge_length(edge_id) *
                     min([self.num_lanes(edge_id), lanes_distribution])
                     for edge_id in initial_config.edges_distribution])

        min_gap = max(0, initial_config.min_gap)

        if initial_config.edges_distribution == "all":
            available_edges = self.get_edge_list()
        else:
            available_edges = initial_config.edges_distribution

        available_length = \
            distribution_length - lanes_distribution * bunching - \
            num_vehicles * (min_gap + VEHICLE_LENGTH)

        if available_length < 0:
            raise ValueError("There is not enough space to place all vehicles "
                             "in the network.")

        return (x0, min_gap, bunching, lanes_distribution, available_length,
                available_edges, initial_config)
